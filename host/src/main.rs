//use std::{hash, ptr::hash};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use merkletree::*;
use methods::{SEMAPHORE_GUEST_ELF, SEMAPHORE_GUEST_ID};
use risc0_zkvm::{
    default_prover,
    sha::rust_crypto::{Digest as _, Sha256},
    ExecutorEnv,
};
use std::time::Instant;

struct ProverInputs {
    external_nullifier: [u8; 32],
    signal_hash: [u8; 32],
    identity_nullifier: [u8; 32],
    identity_trapdoor: [u8; 32],
    leaf_index: usize,
    tree_size: u64,
}

impl ProverInputs {
    fn new(
        external_nullifier: u64,
        signal_hash: u64,
        identity_nullifier: u64,
        identity_trapdoor: u64,
        leaf_index: usize,
        tree_size: u64,
    ) -> Self {
        let external_nullifier = u64_to_bytes(external_nullifier);
        let signal_hash = u64_to_bytes(signal_hash);
        let identity_nullifier = u64_to_bytes(identity_nullifier);
        let identity_trapdoor = u64_to_bytes(identity_trapdoor);
        Self {
            external_nullifier,
            signal_hash,
            identity_nullifier,
            identity_trapdoor,
            leaf_index,
            tree_size,
        }
    }
}

fn dummy_tree(
    tree_size: u64,
    leaf_index: usize,
    insert_leave: [u8; 32],
) -> merkletree::MerkleTree<[u8; 32]> {
    let mut tree_leafes: Vec<[u8; 32]> = (1u64..=tree_size).map(|x: u64| u64_to_bytes(x)).collect();
    tree_leafes[leaf_index] = insert_leave.try_into().unwrap();
    merkletree::MerkleTree::<[u8; 32]>::new(tree_leafes)
}

fn main() {
    let j = 2u64.pow(20);
    let total_time = Instant::now();
    let witness_generation_time = Instant::now();
    //env_logger::init();
    let pin = ProverInputs::new(42, 99, 111222333, 222333444, 1, j);

    // construct the secret and nullifier
    let identity_commitment = Sha256::digest(hash2(pin.identity_nullifier, pin.identity_trapdoor));
    let nullifier_hash = hash2(pin.external_nullifier, pin.identity_nullifier);

    // make a dummy merkle tree, insert identity_commitment and get a proof of it
    let tree_construction_time = Instant::now();
    let t = dummy_tree(
        pin.tree_size,
        pin.leaf_index,
        identity_commitment.try_into().unwrap(),
    );
    let root: [u8; 32] = t.root().try_into().unwrap();
    let proof = t.prove(pin.leaf_index);
    let tree_construction_duration = tree_construction_time.elapsed();

    // Inputs to the circuit:
    // private inputs: identity_nullifier, identity_trapdoor, leaf_index, tree_siblings
    // public inputs: signal_hash, external_nullifier, root, nullifier_hash
    let private_inputs = (pin.identity_nullifier, pin.identity_trapdoor, proof);
    let public_inputs = (
        pin.signal_hash,
        pin.external_nullifier,
        root,
        nullifier_hash,
    );

    let env = ExecutorEnv::builder()
        .write(&private_inputs)
        .unwrap()
        .write(&public_inputs)
        .unwrap()
        .build()
        .unwrap();

    let witness_generation_duration = witness_generation_time.elapsed();

    let proving_time = Instant::now();
    // Obtain the default prover.
    let prover = default_prover();
    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env, SEMAPHORE_GUEST_ELF).unwrap();
    let proving_duration = proving_time.elapsed();

    let verification_time = Instant::now();

    let _output: (bool, [u8; 32], [u8; 32], [u8; 32], [u8; 32]) = receipt.journal.decode().unwrap();
    println!("Guest code verification success: {:?}", _output.0);
    // Optional: Verify receipt to confirm that recipients will also be able to
    receipt.verify(SEMAPHORE_GUEST_ID).unwrap();
    let verification_duration = verification_time.elapsed();
    let total_duration = total_time.elapsed();

    //let segments = receipt.inner.flat().unwrap().len();
    //println!("Number of segments: {}", segments);
    println!("Size of Merkle Tree {}", pin.tree_size);
    println!("It took {:?} to execute in total", total_duration);
    println!(
        "Witness_generation: {:?}, thereof {:?} for tree construction",
        witness_generation_duration, tree_construction_duration
    );
    println!("proving_duration: {:?}", proving_duration);
    println!("verification_duration: {:?}", verification_duration);
}
