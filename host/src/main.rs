use std::{hash, ptr::hash};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{SEMAPHORE_GUEST_ELF, SEMAPHORE_GUEST_ID};

use merkle_light::merkle::MerkleTree;
use merkle_light::{
    hash::{Algorithm, Hashable},
    proof::Proof,
};
use merkletree::*;
use risc0_zkvm::{
    default_prover,
    sha::{
        rust_crypto::{Digest as _, Sha256},
        Digest,
    },
    ExecutorEnv,
};
use serde::{Deserialize, Serialize};

struct ProverInputs {
    external_nullifier: [u8; 32],
    signal_hash: [u8; 32],
    identity_nullifier: [u8; 32],
    identity_trapdoor: [u8; 32],
    leaf_index: usize,
    tree_size: u64,
}

impl ProverInputs {
    fn new(
        external_nullifier: u64,
        signal_hash: u64,
        identity_nullifier: u64,
        identity_trapdoor: u64,
        leaf_index: usize,
        tree_size: u64,
    ) -> Self {
        let external_nullifier = u64_to_bytes(external_nullifier);
        let signal_hash = u64_to_bytes(signal_hash);
        let identity_nullifier = u64_to_bytes(identity_nullifier);
        let identity_trapdoor = u64_to_bytes(identity_trapdoor);
        Self {
            external_nullifier,
            signal_hash,
            identity_nullifier,
            identity_trapdoor,
            leaf_index,
            tree_size,
        }
    }
}

fn dummy_tree(
    tree_size: u64,
    leaf_index: usize,
    insert_leave: [u8; 32],
) -> merkletree::MerkleTree<[u8; 32]> {
    let mut tree_leafes: Vec<[u8; 32]> = (1u64..=tree_size).map(|x: u64| u64_to_bytes(x)).collect();
    tree_leafes[leaf_index] = insert_leave.try_into().unwrap();
    merkletree::MerkleTree::<[u8; 32]>::new(tree_leafes)
}

fn main() {
    env_logger::init();
    let pin = ProverInputs::new(42, 99, 111222333, 222333444, 1, 20);

    // construct the secret and nullifier
    let identity_commitment = Sha256::digest(hash2(pin.identity_nullifier, pin.identity_trapdoor));
    let nullifier_hash = hash2(pin.external_nullifier, pin.identity_nullifier);

    // make a dummy merkle tree, insert identity_commitment and get a proof of it
    let t = dummy_tree(
        pin.tree_size,
        pin.leaf_index,
        identity_commitment.try_into().unwrap(),
    );
    let root: [u8; 32] = t.root().try_into().unwrap();
    let proof = t.prove(pin.leaf_index);

    // Inputs to the circuit:
    // private inputs: identity_nullifier, identity_trapdoor, leaf_index, tree_siblings
    // public inputs: signal_hash, external_nullifier, root, nullifier_hash
    let private_inputs = (pin.identity_nullifier, pin.identity_trapdoor, proof);
    let public_inputs = (
        pin.signal_hash,
        pin.external_nullifier,
        root,
        nullifier_hash,
    );

    let env = ExecutorEnv::builder()
        .write(&private_inputs)
        .unwrap()
        .write(&public_inputs)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();
    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env, SEMAPHORE_GUEST_ELF).unwrap();
    let _output: (bool, [u8; 32], [u8; 32], [u8; 32], [u8; 32]) = receipt.journal.decode().unwrap();
    println!("Guest code result: {:?}", _output);
    // Optional: Verify receipt to confirm that recipients will also be able to
    receipt.verify(SEMAPHORE_GUEST_ID).unwrap();
}
